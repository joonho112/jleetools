% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/full_join_track.R
\name{full_join_track}
\alias{full_join_track}
\title{Perform a Full Join with Merge Diagnostics and Tracking}
\usage{
full_join_track(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  .merge = FALSE,
  merge_var_name = "merge_result",
  ...
)
}
\arguments{
\item{x}{A data frame or tibble. The left data frame for the join.}

\item{y}{A data frame or tibble. The right data frame for the join.}

\item{by}{A character vector of variables to join by. If \code{NULL}, the default, joins by all variables with common names in both data frames.}

\item{suffix}{A character vector of length 2. Suffixes to be added to disambiguate overlapping column names.}

\item{.merge}{Logical. Should a merge tracking variable be added? Defaults to \code{FALSE}.}

\item{merge_var_name}{Character. The name of the merge tracking variable, if added. Defaults to \code{"merge_result"}.}

\item{...}{Additional arguments passed to \code{\link[dplyr:mutate-joins]{dplyr::full_join()}}.}
}
\value{
A data frame resulting from the full join of \code{x} and \code{y}, with optional merge tracking.
}
\description{
\code{full_join_track} performs a full join on two data frames and provides merge diagnostics.
It can optionally add a tracking variable indicating the source of each row.
}
\details{
\itemize{
\item The function prints diagnostics about the number of rows matched and unmatched from each data frame.
\item If \code{.merge = TRUE}, a variable is added to indicate whether a row is from \code{x} only, \code{y} only, or matched.
}
}
\examples{
df1 <- tibble::tibble(id = 1:5, value1 = letters[1:5])
df2 <- tibble::tibble(id = 3:7, value2 = letters[3:7])

# Perform a full join with diagnostics
full_join_track(df1, df2, by = "id")

# Perform a full join and add a tracking variable
full_join_track(df1, df2, by = "id", .merge = TRUE)

}
